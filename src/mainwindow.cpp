/* mainwindow.cpp - implements the MainWindow class, which implements
                    the program's main window and virtually all UI-related things.

 This file is part of QMPlot licensed under GPLv2.

 Copyright (C) Piotr Dziwinski 2009-2010
*/

#include "mainwindow.h"
#include "dialogs.h"
#include "../build/ui_mainwindow.h"

#include <QSettings>
#include <QTranslator>
#include <QListWidgetItem>
#include <QMessageBox>
#include <QPixmap>
#include <QFileDialog>
#include <QFileInfo>
#include <QCloseEvent>


// -------- MainWindow --------


MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), _ui(new Ui::MainWindow)
{
  /* List translation files before loading settings because
      maximum language index must be known */
  listTranslationFiles();

  // Construct and load settings before creating UI to avoid retranslating
  _settings = new QSettings("QMPlot", "QMPlot");
  loadSettings();

  _translator = new QTranslator(this);
  _translator->load(_translationFiles.at(_settingsData.language));
  qApp->installTranslator(_translator);

  // Now list translated translation names
  listTranslationNames();

  _ui->setupUi(this);
  connect(this, SIGNAL(languageChanged()),
          _ui->fColorButton, SLOT(retranslateUi()));

  _functionDB = new FunctionDB();
  _currentFunction = NULL;

  _exportDialog = new ExportDialog(this);
  connect(_exportDialog, SIGNAL(accepted()),
          this, SLOT(exportDialogAccepted()));
  connect(this, SIGNAL(languageChanged()),
          _exportDialog, SLOT(retranslateUi()));

  _preferencesDialog = new PreferencesDialog(this, _translations);
  connect(_preferencesDialog, SIGNAL(accepted()),
          this, SLOT(preferencesDialogAccepted()));
  connect(this, SIGNAL(languageChanged()),
          _preferencesDialog, SLOT(retranslateUi()));

  _referenceDialog = new ReferenceDialog(this);
  connect(this, SIGNAL(languageChanged()),
          _referenceDialog, SLOT(retranslateUi()));

  _aboutDialog = new AboutDialog(this);
  connect(this, SIGNAL(languageChanged()),
          _aboutDialog, SLOT(retranslateUi()));

  setWindowTitle(tr("QMPlot - %1[*]").arg(tr("Untitled")));

  _addCartesianFunctionAction = new QAction(QIcon(":/images/addcartesian.png"),
                                            tr("&Cartesian function"), this);
  _addCartesianFunctionAction->setStatusTip(tr("Add cartesian function"));
  connect(_addCartesianFunctionAction, SIGNAL(triggered()),
          this, SLOT(addCartesianFunction()));

  _addParametricFunctionAction = new QAction(QIcon(":/images/addparametric.png"),
                                             tr("&Parametric function"), this);
  _addParametricFunctionAction->setStatusTip(tr("Add parametric function"));
  connect(_addParametricFunctionAction, SIGNAL(triggered()),
          this, SLOT(addParametricFunction()));

  _addImplicitFunctionAction = new QAction(QIcon(":/images/addimplicit.png"),
                                           tr("&Implcit function"), this);
  _addImplicitFunctionAction->setStatusTip(tr("Add implicit function"));
  connect(_addImplicitFunctionAction, SIGNAL(triggered()),
          this, SLOT(addImplicitFunction()));

  // Menu associated with add function button
  QMenu *addMenu = new QMenu(this);
  addMenu->addAction(_addCartesianFunctionAction);
  addMenu->addAction(_addParametricFunctionAction);
  addMenu->addAction(_addImplicitFunctionAction);

  _ui->addButton->setMenu(addMenu);

  addMenu = NULL;

  // Fill the toolbar

  _ui->toolBar->addAction(_ui->actionNew);

  _ui->toolBar->addSeparator();
  _ui->toolBar->addAction(_ui->actionOpen);
  _ui->toolBar->addAction(_ui->actionSave);
  _ui->toolBar->addAction(_ui->actionSaveAs);

  _ui->toolBar->addSeparator();
  _ui->toolBar->addAction(_ui->actionPreferences);

  _ui->toolBar->addSeparator();
  _ui->toolBar->addAction(_ui->actionReference);

  // Events generated by PlotArea, of mouse or keyboard input

  connect(_ui->plot, SIGNAL(unitScaleChanged(double)),
          _ui->unitScaleEdit, SLOT(setValue(double)));
  connect(_ui->plot, SIGNAL(translateXChanged(double)),
          _ui->txEdit, SLOT(setValue(double)));
  connect(_ui->plot, SIGNAL(translateYChanged(double)),
          _ui->tyEdit, SLOT(setValue(double)));
  connect(_ui->plot, SIGNAL(axisUnitChanged(double)),
          _ui->axisUnitEdit, SLOT(setValue(double)));
  connect(_ui->plot, SIGNAL(recursionDetected(const QString &)),
          this, SLOT(recursionDetected(const QString &)), Qt::QueuedConnection);

  // Function list dock events

  connect(_ui->functionsList, SIGNAL(itemChanged(QListWidgetItem*)),
          this, SLOT(functionListItemChanged(QListWidgetItem*)));
  connect(_ui->functionsList, SIGNAL(currentTextChanged(const QString &)),
        this, SLOT(functionSelected(const QString &)));
  connect(_ui->removeButton, SIGNAL(clicked()),
          this, SLOT(removeCurrentFunction()));

  // Function properties dock events

  // Common to all functions

  connect(_ui->fNameEdit, SIGNAL(editingFinished()),
          this, SLOT(fNameChanged()));
  connect(_ui->fWidthSpinBox, SIGNAL(valueChanged(double)),
          this, SLOT(fWidthChanged(double)));
  connect(_ui->fColorButton, SIGNAL(colorEdited(const QColor &)),
          this, SLOT(fColorChanged(const QColor &)));

  // From specific function page on widget stack

  // Cartesian function

  connect(_ui->cTypeComboBox, SIGNAL(currentIndexChanged(int)),
          this, SLOT(cTypeChanged(int)));
  connect(_ui->cFormulaEdit, SIGNAL(editingFinished()),
          this, SLOT(cFormulaChanged()));
  connect(_ui->cMinCheckBox, SIGNAL(toggled(bool)),
          this, SLOT(cMinFChanged(bool)));
  connect(_ui->cMinEdit, SIGNAL(editingFinished(double, bool)),
          this, SLOT(cMinChanged(double, bool)));
  connect(_ui->cMaxCheckBox, SIGNAL(toggled(bool)),
          this, SLOT(cMaxFChanged(bool)));
  connect(_ui->cMaxEdit, SIGNAL(editingFinished(double, bool)),
          this, SLOT(cMaxChanged(double, bool)));

  // Parametric function

  connect(_ui->pXFormulaEdit, SIGNAL(editingFinished()),
          this, SLOT(pXFormulaChanged()));
  connect(_ui->pYFormulaEdit, SIGNAL(editingFinished()),
          this, SLOT(pYFormulaChanged()));

  connect(_ui->pMinParamEdit, SIGNAL(editingFinished(double, bool)),
          this, SLOT(pMinParamChanged(double, bool)));
  connect(_ui->pMaxParamEdit, SIGNAL(editingFinished(double, bool)),
          this, SLOT(pMaxParamChanged(double, bool)));
  connect(_ui->pParamStepEdit, SIGNAL(editingFinished(double, bool)),
          this, SLOT(pParamStepChanged(double, bool)));

  // Implicit function

  connect(_ui->iFormulaEdit, SIGNAL(editingFinished()),
          this, SLOT(iFormulaChanged()));
  connect(_ui->iDrawAccuracyEdit, SIGNAL(editingFinished(double, bool)),
          this, SLOT(iDrawAccuracyChanged(double, bool)));

  // View properties dock events

  connect(_ui->unitScaleEdit, SIGNAL(editingFinished(double, bool)),
          this, SLOT(unitScaleChanged(double, bool)));
  connect(_ui->txEdit, SIGNAL(editingFinished(double, bool)),
          this, SLOT(txChanged(double, bool)));
  connect(_ui->tyEdit, SIGNAL(editingFinished(double, bool)),
          this, SLOT(tyChanged(double, bool)));
  connect(_ui->axisUnitCheckBox, SIGNAL(toggled(bool)),
          this, SLOT(axisUnitFChanged(bool)));
  connect(_ui->axisUnitEdit, SIGNAL(editingFinished(double, bool)),
          this, SLOT(axisUnitChanged(double, bool)));

  // Actions in menu & toolbar

  connect(_ui->actionNew, SIGNAL(triggered()),
          this, SLOT(actionNew()));
  connect(_ui->actionOpen, SIGNAL(triggered()),
          this, SLOT(actionOpen()));
  connect(_ui->actionSave, SIGNAL(triggered()),
          this, SLOT(actionSave()));
  connect(_ui->actionSaveAs, SIGNAL(triggered()),
          this, SLOT(actionSaveAs()));
  connect(_ui->actionExport, SIGNAL(triggered()),
          this, SLOT(actionExport()));
  connect(_ui->actionQuit, SIGNAL(triggered()),
          this, SLOT(close()));

  connect(_ui->actionDisplayFunctionsList, SIGNAL(triggered(bool)),
          _ui->listDock, SLOT(setVisible(bool)));
  connect(_ui->actionDisplayFunctionProperties, SIGNAL(triggered(bool)),
          _ui->propertiesDock, SLOT(setVisible(bool)));
  connect(_ui->actionDisplayViewProperties, SIGNAL(triggered(bool)),
          _ui->viewDock, SLOT(setVisible(bool)));

  connect(_ui->listDock, SIGNAL(visibilityChanged(bool)),
          _ui->actionDisplayFunctionsList, SLOT(setChecked(bool)));
  connect(_ui->propertiesDock, SIGNAL(visibilityChanged(bool)),
          _ui->actionDisplayFunctionProperties, SLOT(setChecked(bool)));
  connect(_ui->viewDock, SIGNAL(visibilityChanged(bool)),
          _ui->actionDisplayViewProperties, SLOT(setChecked(bool)));

  connect(_ui->actionPreferences, SIGNAL(triggered()),
          this, SLOT(actionPreferences()));

  connect(_ui->actionReference, SIGNAL(triggered()),
          _referenceDialog, SLOT(show()));
  connect(_ui->actionAbout, SIGNAL(triggered()),
          _aboutDialog, SLOT(show()));
  connect(_ui->actionAboutQt, SIGNAL(triggered()),
          qApp, SLOT(aboutQt()));

  // Connect this signal at the end to ensure the order of retranslation
  connect(this, SIGNAL(languageChanged()),
          this, SLOT(retranslate()));
}

MainWindow::~MainWindow()
{
  qApp->removeTranslator(_translator);
  delete _translator;
  _translator = NULL;

  delete _settings;
  _settings = NULL;

  delete _functionDB;
  _functionDB = NULL;
  _currentFunction = NULL;

  delete _exportDialog;
  _exportDialog = NULL;
  delete _preferencesDialog;
  _preferencesDialog = NULL;
  delete _referenceDialog;
  _referenceDialog = NULL;
  delete _aboutDialog;
  _aboutDialog = NULL;

  delete _addCartesianFunctionAction;
  _addCartesianFunctionAction = NULL;
  delete _addParametricFunctionAction;
  _addParametricFunctionAction = NULL;
  delete _addImplicitFunctionAction;
  _addImplicitFunctionAction = NULL;

  delete _ui;
  _ui = NULL;
}

void MainWindow::listTranslationNames()
{
  _translations.clear();
  _translations << tr("English");
  _translations << tr("Polish");
}

void MainWindow::listTranslationFiles()
{
  _translationFiles.clear();
  _translationFiles << "";
  _translationFiles << ":/tr/qmplot_pl.qm";
}

void MainWindow::loadSettings()
{
  _settingsData = Settings();

  _settingsData.numberFormat = static_cast<NumberFormat>
      ( _settings->value("parser/number_format",
                         QVariant(static_cast<int>(_settingsData.numberFormat))).toInt() );
  _settingsData.numberPrecision = _settings->value("parser/number_precision",
                         QVariant(_settingsData.numberPrecision)).toInt();
  _settingsData.language = _settings->value("ui/language_index",
                         QVariant(_settingsData.language)).toInt();

  if (_settingsData.language >= _translationFiles.size())
    _settingsData.language = 0;

  _settingsData.warnUnsavedNew = _settings->value("ui/warn_unsaved_new",
                         QVariant(_settingsData.warnUnsavedNew)).toBool();
  _settingsData.warnUnsavedAtExit = _settings->value("ui/warn_unsaved_exit",
                         QVariant(_settingsData.warnUnsavedAtExit)).toBool();
}

void MainWindow::saveSettings()
{
  _settings->setValue("parser/number_format", QVariant(static_cast<int>(_settingsData.numberFormat)));
  _settings->setValue("parser/number_precision", QVariant(_settingsData.numberPrecision));
  _settings->setValue("ui/language_index", QVariant(_settingsData.language));
  _settings->setValue("ui/warn_unsaved_new", QVariant(_settingsData.warnUnsavedNew));
  _settings->setValue("ui/warn_unsaved_exit", QVariant(_settingsData.warnUnsavedAtExit));
}

void MainWindow::settingsChanged(const Settings &newSettings)
{
  if (newSettings.language != _settingsData.language)
  {
    _translator->load(_translationFiles.at(newSettings.language));
    // List translation names with the new translator here, before other retranslations
    listTranslationNames();
    emit languageChanged();
  }

  _settingsData = newSettings;

  TreeParser::setNumberFormat(_settingsData.numberFormat);
  TreeParser::setNumberPrecision(_settingsData.numberPrecision);
}

void MainWindow::retranslate()
{
  disconnect(_ui->fWidthSpinBox, SIGNAL(valueChanged(double)),
             this, SLOT(fWidthChanged(double)));
  disconnect(_ui->cTypeComboBox, SIGNAL(currentIndexChanged(int)),
             this, SLOT(cTypeChanged(int)));
  disconnect(_ui->cMinCheckBox, SIGNAL(toggled(bool)),
             this, SLOT(cMinFChanged(bool)));
  disconnect(_ui->cMaxCheckBox, SIGNAL(toggled(bool)),
             this, SLOT(cMaxFChanged(bool)));
  _ui->retranslateUi(this);
  connect(_ui->fWidthSpinBox, SIGNAL(valueChanged(double)),
          this, SLOT(fWidthChanged(double)));
  connect(_ui->cTypeComboBox, SIGNAL(currentIndexChanged(int)),
          this, SLOT(cTypeChanged(int)));
  connect(_ui->cMinCheckBox, SIGNAL(toggled(bool)),
          this, SLOT(cMinFChanged(bool)));
  connect(_ui->cMaxCheckBox, SIGNAL(toggled(bool)),
          this, SLOT(cMaxFChanged(bool)));

  if (_fileName.isEmpty())
    setWindowTitle(tr("QMPlot - %1[*]").arg(tr("Untitled")));
  else
  {
    QFileInfo info(_fileName);
    setWindowTitle(tr("QMPlot - %1[*]").arg(info.baseName()));
  }

  _addCartesianFunctionAction->setText(tr("&Cartesian function"));
  _addCartesianFunctionAction->setStatusTip(tr("Add cartesian function"));

  _addParametricFunctionAction->setText(tr("&Parametric function"));
  _addParametricFunctionAction->setStatusTip(tr("Add parametric function"));

  _addImplicitFunctionAction->setText(tr("&Implcit function"));
  _addImplicitFunctionAction->setStatusTip(tr("Add implicit function"));

  if (_currentFunction != NULL) functionChanged();
}

void MainWindow::reset()
{
  setWindowModified(false);

  if (_ui->functionsList->count() > 0)
  {
    disconnect(_ui->functionsList, SIGNAL(currentTextChanged(const QString &)),
               this, SLOT(functionSelected(const QString &)));

    _ui->functionsList->clear();
  }

  _functionDB->clear();
  _currentFunction = NULL;

  _fileName = "";

  _ui->propertiesDock->setEnabled(false);
  // Empty page on stacked widget
  _ui->optionsStack->setCurrentIndex(3);
  _ui->removeButton->setEnabled(false);

  _ui->axisUnitCheckBox->setChecked(false);
  _ui->axisUnitEdit->setEnabled(false);
  _ui->plot->reset();
}

void MainWindow::functionListItemChanged(QListWidgetItem *item)
{
  Q_ASSERT(item != NULL);
  Q_ASSERT(_currentFunction != NULL);

  bool enabled = true;
  if (item->checkState() == Qt::Checked)
    enabled = true;
  else if (item->checkState() == Qt::Unchecked)
    enabled = false;

  if (_currentFunction->enabled() != enabled)
  {
    _currentFunction->enabled() = enabled;
    _ui->plot->update();
  }
}

// Called when function is selected from list
void MainWindow::functionSelected(const QString &name)
{
  if (_currentFunction != NULL)
  {
    // Avoid unncecessary changes
    if (_currentFunction->name() == name) return;
  }
  _currentFunction = _functionDB->function(name);
  Q_ASSERT(_currentFunction != NULL);

  functionChanged();
}

void MainWindow::addCartesianFunction()
{
  Function *newFunction = _functionDB->addFunction(FT_Cartesian);
  Q_ASSERT(newFunction != NULL);
  functionAdded(newFunction);
  newFunction = NULL;
}

void MainWindow::addParametricFunction()
{
  Function *newFunction = _functionDB->addFunction(FT_Parametric);
  Q_ASSERT(newFunction != NULL);
  functionAdded(newFunction);
  newFunction = NULL;
}

void MainWindow::addImplicitFunction()
{
  Function *newFunction = _functionDB->addFunction(FT_Implicit);
  Q_ASSERT(newFunction != NULL);
  functionAdded(newFunction);
  newFunction = NULL;
}

void MainWindow::functionAdded(Function *newFunction)
{
  Q_ASSERT(newFunction != NULL);

  setWindowModified(true);

  QListWidgetItem *item = new QListWidgetItem;
  item->setFlags(item->flags() | Qt::ItemIsUserCheckable);
  item->setCheckState(Qt::Checked);
  item->setText(newFunction->name());
  item->setForeground(QBrush(newFunction->color()));

  _ui->functionsList->addItem(item);

  item = NULL;

  if (_ui->functionsList->count() > 0)
  {
    disconnect(_ui->functionsList, SIGNAL(currentTextChanged(const QString &)),
               this, SLOT(functionSelected(const QString &)));
  }

  _ui->functionsList->setCurrentRow(_ui->functionsList->count() - 1);

  connect(_ui->functionsList, SIGNAL(currentTextChanged(const QString &)),
          this, SLOT(functionSelected(const QString &)));

  _ui->propertiesDock->setEnabled(true);

  _ui->removeButton->setEnabled(true);

  _currentFunction = newFunction;
  functionChanged();

  _ui->plot->update();
}

void MainWindow::removeCurrentFunction()
{
  Q_ASSERT(_currentFunction != NULL);
  Q_ASSERT(_ui->functionsList->count() > 0);

  bool result = _functionDB->removeFunction(_currentFunction->name());
  Q_ASSERT(result);

  setWindowModified(true);

  if (_ui->functionsList->count() == 1)
  {
    _ui->removeButton->setEnabled(false);
    // Empty page on stacked widget
    _ui->optionsStack->setCurrentIndex(3);
    _ui->propertiesDock->setEnabled(false);

    disconnect(_ui->functionsList, SIGNAL(currentTextChanged(const QString &)),
               this, SLOT(functionSelected(const QString &)));
  }

  QListWidgetItem *item = _ui->functionsList->takeItem(_ui->functionsList->currentRow());
  Q_ASSERT(item != NULL);

  delete item;
  item = NULL;

  _ui->plot->update();
}

// Called when function changes, or is modified and in other places to synchronize
// UI with the Function data
void MainWindow::functionChanged()
{
  Q_ASSERT(_currentFunction != NULL);

  // These hasve to be disconnected to avoid double changing the values
  disconnect(_ui->fWidthSpinBox, SIGNAL(valueChanged(double)),
             this, SLOT(fWidthChanged(double)));
  disconnect(_ui->cTypeComboBox, SIGNAL(currentIndexChanged(int)),
             this, SLOT(cTypeChanged(int)));
  disconnect(_ui->cMinCheckBox, SIGNAL(toggled(bool)),
             this, SLOT(cMinFChanged(bool)));
  disconnect(_ui->cMaxCheckBox, SIGNAL(toggled(bool)),
             this, SLOT(cMaxFChanged(bool)));

  _ui->fNameEdit->setText(_currentFunction->name());
  _ui->fWidthSpinBox->setValue(_currentFunction->width());
  _ui->fColorButton->setColor(_currentFunction->color());

  switch (_currentFunction->type())
  {
    case FT_Cartesian:
    {
      CartesianFunction *cFunction = static_cast<CartesianFunction*>(_currentFunction);

      _ui->typeLabel->setText(tr("Cartesian function"));

      // Cartesian page on stacked widget
      _ui->optionsStack->setCurrentIndex(0);

      if (cFunction->subtype() == CT_XToY)
      {
        _ui->cTypeComboBox->setCurrentIndex(0);
        _ui->cEquationLabel->setText(QString("y = %1(x) =").arg(cFunction->name()));
      }
      else if (cFunction->subtype() == CT_YToX)
      {
        _ui->cTypeComboBox->setCurrentIndex(1);
        _ui->cEquationLabel->setText(QString("x = %1(y) =").arg(cFunction->name()));
      }

      // Disable sending editingFinished() signal after a second
      _ui->cFormulaEdit->disableSignal();
      _ui->cFormulaEdit->setPlainText(
          QString::fromStdString(cFunction->formula().expression()));
      // But call the slot of the above signal explicitly here to update verification
      cFormulaChanged();
      _ui->cFormulaEdit->enableSignal();

      _ui->cMinCheckBox->setChecked(cFunction->minF());
      _ui->cMinEdit->setEnabled(cFunction->minF());
      _ui->cMinEdit->setValue(cFunction->min());
      _ui->cMaxCheckBox->setChecked(cFunction->maxF());
      _ui->cMaxEdit->setEnabled(cFunction->maxF());
      _ui->cMaxEdit->setValue(cFunction->max());

      cFunction = NULL;
      break;
    }
    case FT_Parametric:
    {
      ParametricFunction *pFunction = static_cast<ParametricFunction*>(_currentFunction);

      _ui->typeLabel->setText(tr("Parametric function"));

      // Parametric page on stacked widget
      _ui->optionsStack->setCurrentIndex(1);

      _ui->pXEquationLabel->setText(QString("%1_x(t) = ").arg(pFunction->name()));
      _ui->pXEquationLabel->setText(QString("%1_y(t) = ").arg(pFunction->name()));

      _ui->pXFormulaEdit->disableSignal();
      _ui->pXFormulaEdit->setPlainText(
          QString::fromStdString(pFunction->xFormula().expression()));
      pXFormulaChanged();
      _ui->pXFormulaEdit->enableSignal();

      _ui->pYFormulaEdit->disableSignal();
      _ui->pYFormulaEdit->setPlainText(
          QString::fromStdString(pFunction->yFormula().expression()));
      pYFormulaChanged();
      _ui->pYFormulaEdit->enableSignal();

      _ui->pMinParamEdit->setValue(pFunction->minParam());
      _ui->pMaxParamEdit->setValue(pFunction->maxParam());
      _ui->pParamStepEdit->setValue(pFunction->paramStep());

      pFunction = NULL;
      break;
    }
    case FT_Implicit:
    {
      ImplicitFunction *iFunction = static_cast<ImplicitFunction*>(_currentFunction);

      _ui->typeLabel->setText(tr("Implicit function"));

      // Implicit page on stacked widget
      _ui->optionsStack->setCurrentIndex(2);

      _ui->iEquationLabel->setText(QString("%1(x, y) = ").arg(iFunction->name()));

      _ui->iFormulaEdit->disableSignal();
      _ui->iFormulaEdit->setPlainText(
          QString::fromStdString(iFunction->formula().expression()));
      iFormulaChanged();
      _ui->iFormulaEdit->enableSignal();

      _ui->iDrawAccuracyEdit->setValue(iFunction->drawAccuracy());

      iFunction = NULL;
      break;
    }
  }

  connect(_ui->fWidthSpinBox, SIGNAL(valueChanged(double)),
          this, SLOT(fWidthChanged(double)));
  connect(_ui->cTypeComboBox, SIGNAL(currentIndexChanged(int)),
          this, SLOT(cTypeChanged(int)));
  connect(_ui->cMinCheckBox, SIGNAL(toggled(bool)),
          this, SLOT(cMinFChanged(bool)));
  connect(_ui->cMaxCheckBox, SIGNAL(toggled(bool)),
          this, SLOT(cMaxFChanged(bool)));
}

void MainWindow::fNameChanged()
{
  Q_ASSERT(_currentFunction != NULL);

  setWindowModified(true);

  QString oldName = _currentFunction->name();
  QString newName = _ui->fNameEdit->text();

  if (newName.isEmpty())
  {
    _ui->fNameEdit->setText(oldName);
    return;
  }

  if (!_functionDB->changeName(oldName, newName))
  {
    _ui->fNameEdit->setText(oldName);
    return;
  }

  QListWidgetItem *item = _ui->functionsList->currentItem();
  Q_ASSERT(item != NULL);
  item->setText(newName);
  item = NULL;

  functionChanged();
}

void MainWindow::fWidthChanged(double value)
{
  Q_ASSERT(_currentFunction != NULL);

  setWindowModified(true);
  _currentFunction->width() = value;
  _ui->plot->update();
}

void MainWindow::fColorChanged(const QColor &color)
{
  Q_ASSERT(_currentFunction != NULL);

  setWindowModified(true);
  _currentFunction->color() = color;

  QListWidgetItem *item = _ui->functionsList->currentItem();
  Q_ASSERT(item != NULL);
  item->setForeground(QBrush(color));
  item = NULL;

  _ui->plot->update();
}

void MainWindow::cTypeChanged(int type)
{
  Q_ASSERT(_currentFunction != NULL);
  Q_ASSERT(_currentFunction->type() == FT_Cartesian);

  setWindowModified(true);

  CartesianType subtype = CT_XToY;
  if (type == 0)
    subtype = CT_XToY;
  else if (type == 1)
    subtype = CT_YToX;

  (static_cast<CartesianFunction*>(_currentFunction))->subtype() = subtype;

  functionChanged();
}

void MainWindow::cFormulaChanged()
{
  Q_ASSERT(_currentFunction != NULL);
  Q_ASSERT(_currentFunction->type() == FT_Cartesian);

  setWindowModified(true);

  CartesianFunction *cFunction = static_cast<CartesianFunction*>(_currentFunction);
  if (!cFunction->formula().setExpression(_ui->cFormulaEdit->toPlainText().toStdString()))
  {
    _ui->cFormulaStatus->setText(generateErrorMessage(cFunction->formula().status()));
    _ui->cFormulaStatusIcon->setPixmap(QPixmap(":/img/critical.png"));
  }
  else
  {
    if (!_functionDB->verifyFunction(cFunction->name()))
    {
      _ui->cFormulaStatus->setText(generateErrorMessage(_functionDB->verifyError()));
      _ui->cFormulaStatusIcon->setPixmap(QPixmap(":/img/critical.png"));
    }
    else
    {
      _ui->cFormulaStatus->setText(tr("Expression is valid."));
      _ui->cFormulaStatusIcon->setPixmap(QPixmap(":/img/ok.png"));
    }
  }

  _ui->plot->update();
}

void MainWindow::cMinFChanged(bool on)
{
  Q_ASSERT(_currentFunction != NULL);
  Q_ASSERT(_currentFunction->type() == FT_Cartesian);

  setWindowModified(true);
  (static_cast<CartesianFunction*>(_currentFunction))->minF() = on;
  _ui->cMinEdit->setEnabled(on);
  _ui->plot->update();
}

void MainWindow::cMinChanged(double value, bool valid)
{
  Q_ASSERT(_currentFunction != NULL);
  Q_ASSERT(_currentFunction->type() == FT_Cartesian);

  if (!valid) return;

  setWindowModified(true);
  (static_cast<CartesianFunction*>(_currentFunction))->min() = value;
  _ui->plot->update();
}

void MainWindow::cMaxFChanged(bool on)
{
  Q_ASSERT(_currentFunction != NULL);
  Q_ASSERT(_currentFunction->type() == FT_Cartesian);

  setWindowModified(true);
  (static_cast<CartesianFunction*>(_currentFunction))->maxF() = on;
  _ui->cMaxEdit->setEnabled(on);
  _ui->plot->update();
}

void MainWindow::cMaxChanged(double value, bool valid)
{
  Q_ASSERT(_currentFunction != NULL);
  Q_ASSERT(_currentFunction->type() == FT_Cartesian);

  if (!valid) return;

  setWindowModified(true);
  (static_cast<CartesianFunction*>(_currentFunction))->max() = value;
  _ui->plot->update();
}

void MainWindow::pXFormulaChanged()
{
  Q_ASSERT(_currentFunction != NULL);
  Q_ASSERT(_currentFunction->type() == FT_Parametric);

  ParametricFunction *pFunction = static_cast<ParametricFunction*>(_currentFunction);
  if (!pFunction->xFormula().setExpression(_ui->pXFormulaEdit->toPlainText().toStdString()))
  {
    _ui->pXFormulaStatus->setText(generateErrorMessage(pFunction->xFormula().status()));
    _ui->pXFormulaStatusIcon->setPixmap(QPixmap(":/img/critical.png"));
  }
  else
  {
    if (!_functionDB->verifyFunction(pFunction->name()))
    {
      _ui->pXFormulaStatus->setText(generateErrorMessage(_functionDB->verifyError()));
      _ui->pXFormulaStatusIcon->setPixmap(QPixmap(":/img/critical.png"));
    }
    else
    {
      _ui->pXFormulaStatus->setText(tr("Expression is valid."));
      _ui->pXFormulaStatusIcon->setPixmap(QPixmap(":/img/ok.png"));
    }
  }

  _ui->plot->update();
}

void MainWindow::pYFormulaChanged()
{
  Q_ASSERT(_currentFunction != NULL);
  Q_ASSERT(_currentFunction->type() == FT_Parametric);

  ParametricFunction *pFunction = static_cast<ParametricFunction*>(_currentFunction);
  if (!pFunction->yFormula().setExpression(_ui->pYFormulaEdit->toPlainText().toStdString()))
  {
    _ui->pYFormulaStatus->setText(generateErrorMessage(pFunction->yFormula().status()));
    _ui->pYFormulaStatusIcon->setPixmap(QPixmap(":/img/critical.png"));
  }
  else
  {
    if (!_functionDB->verifyFunction(pFunction->name()))
    {
      _ui->pYFormulaStatus->setText(generateErrorMessage(_functionDB->verifyError()));
      _ui->pYFormulaStatusIcon->setPixmap(QPixmap(":/img/critical.png"));
    }
    else
    {
      _ui->pYFormulaStatus->setText(tr("Expression is valid."));
      _ui->pYFormulaStatusIcon->setPixmap(QPixmap(":/img/ok.png"));
    }
  }

  _ui->plot->update();
}

void MainWindow::pMinParamChanged(double value, bool valid)
{
  Q_ASSERT(_currentFunction != NULL);
  Q_ASSERT(_currentFunction->type() == FT_Parametric);

  if (!valid) return;

  setWindowModified(true);
  (static_cast<ParametricFunction*>(_currentFunction))->minParam() = value;
  _ui->plot->update();
}

void MainWindow::pMaxParamChanged(double value, bool valid)
{
  Q_ASSERT(_currentFunction != NULL);
  Q_ASSERT(_currentFunction->type() == FT_Parametric);

  if (!valid) return;

  setWindowModified(true);
  (static_cast<ParametricFunction*>(_currentFunction))->maxParam() = value;
  _ui->plot->update();
}

void MainWindow::pParamStepChanged(double value, bool valid)
{
  Q_ASSERT(_currentFunction != NULL);
  Q_ASSERT(_currentFunction->type() == FT_Parametric);

  if (!valid) return;

  setWindowModified(true);
  (static_cast<ParametricFunction*>(_currentFunction))->paramStep() = value;
  _ui->plot->update();
}

void MainWindow::iFormulaChanged()
{
  Q_ASSERT(_currentFunction != NULL);
  Q_ASSERT(_currentFunction->type() == FT_Implicit);

  ImplicitFunction *iFunction = static_cast<ImplicitFunction*>(_currentFunction);
  if (!iFunction->formula().setExpression(_ui->iFormulaEdit->toPlainText().toStdString()))
  {
    _ui->iFormulaStatus->setText(generateErrorMessage(iFunction->formula().status()));
    _ui->iFormulaStatusIcon->setPixmap(QPixmap(":/img/critical.png"));
  }
  else
  {
    if (!_functionDB->verifyFunction(iFunction->name()))
    {
      _ui->iFormulaStatus->setText(generateErrorMessage(_functionDB->verifyError()));
      _ui->iFormulaStatusIcon->setPixmap(QPixmap(":/img/critical.png"));
    }
    else
    {
      _ui->iFormulaStatus->setText(tr("Expression is valid."));
      _ui->iFormulaStatusIcon->setPixmap(QPixmap(":/img/ok.png"));
    }
  }

  _ui->plot->update();
}

void MainWindow::iDrawAccuracyChanged(double value, bool valid)
{
  Q_ASSERT(_currentFunction != NULL);
  Q_ASSERT(_currentFunction->type() == FT_Implicit);

  if (!valid) return;

  if (value <= 0.1)
  {
    _ui->iDrawAccuracyEdit->setValid(false);
    return;
  }

  setWindowModified(true);
  (static_cast<ImplicitFunction*>(_currentFunction))->drawAccuracy() = value;
  _ui->plot->update();
}

QString MainWindow::generateErrorMessage(ParseStatus status)
{
  QString result;
  switch (status.error)
  {
    case PE_None:
    {
      break;
    }
    case PE_EmptyExpression:
    {
      result = tr("E%1 Empty expression.").arg(status.code);
      break;
    }
    case PE_EmptyBrackets:
    {
      result = tr("E%1 Empty pair of brackets.").arg(status.code);
      break;
    }
    case PE_InvalidNumber:
    {
      result = tr("E%1 A number was given in invalid format.").arg(status.code);
      break;
    }
    case PE_InvalidCharacter:
    {
      result = tr("E%1 An invalid character in expression.").arg(status.code);
      break;
    }
    case PE_MismatchedBrackets:
    {
      result = tr("E%1 Mismatched brackets.").arg(status.code);
      break;
    }
    case PE_MisplacedComma:
    {
      result = tr("E%1 Misplaced comma.").arg(status.code);
      break;
    }
    case PE_MissingArgument:
    {
      result = tr("E%1 Missing argument to \"%2\".").arg(status.code)
                  .arg(QString::fromStdString(status.token.name()));
      break;
    }
    case PE_ExtraArgument:
    {
      result = tr("E%1 Extra argument to \"%2\".").arg(status.code)
                  .arg(QString::fromStdString(status.token.name()));
      break;
    }
    case PE_InvalidArgument:
    {
      result = tr("E%1 Invalid argument to \"%2\".").arg(status.code)
                  .arg(QString::fromStdString(status.token.name()));
      break;
    }
    case PE_GeneralError:
    {
      result = tr("E%1 General error.").arg(status.code);
      break;
    }
    case PE_LogicError:
    {
      result = tr("E%1 Unexpected error (bug?).").arg(status.code);
      break;
    }
  }
  return result;
}

QString MainWindow::generateErrorMessage(VerifyError error)
{
  QString result;
  switch (error)
  {
    case VE_NoError:
    {
      break;
    }
    case VE_MissingVariable:
    {
      result = tr("Missing variable.");
      break;
    }
    case VE_UnresolvedVariable:
    {
      result = tr("Unresolved variable.");
      break;
    }
    case VE_OtherError:
    {
      result = tr("Other error (bug?).");
      break;
    }
  }
  return result;
}

void MainWindow::recursionDetected(const QString &functionName)
{
  for (int i = 0; i < _ui->functionsList->count(); ++i)
  {
    _ui->functionsList->item(i)->setCheckState(Qt::Unchecked);
  }

  QMessageBox::critical(this, tr("QMPlot - error"),
      tr("Recursion was detected while drawing function %1. "
         "All functions have been disabled. Fix the error by removing"
         " the recursion and try again.").arg(functionName),
      QMessageBox::Ok);
}

void MainWindow::unitScaleChanged(double value, bool valid)
{
  if (!valid) return;

  if (!_ui->plot->setUnitScale(value))
    _ui->unitScaleEdit->setValid(false);
}

void MainWindow::txChanged(double value, bool valid)
{
  if (!valid) return;
  _ui->plot->setTranslateX(value);
}

void MainWindow::tyChanged(double value, bool valid)
{
  if (!valid) return;
  _ui->plot->setTranslateY(value);
}

void MainWindow::axisUnitFChanged(bool on)
{
  _ui->axisUnitEdit->setEnabled(on);
  _ui->plot->setManualAxisUnit(_ui->axisUnitEdit->value());
  _ui->plot->setManualAxisUnitF(on);
}

void MainWindow::axisUnitChanged(double value, bool valid)
{
  if (!valid) return;
  if (!_ui->plot->setManualAxisUnit(value))
    _ui->axisUnitEdit->setValid(false);
}

void MainWindow::actionNew()
{
  if (isWindowModified() && _settingsData.warnUnsavedNew)
  {
    WarnUnsavedDialog dialog(this);
    int result = dialog.exec();
    _settingsData.warnUnsavedNew = dialog.checked();
    if (result == QDialog::Accepted) return;
  }

  reset();
}

void MainWindow::actionOpen()
{
  if (isWindowModified() && _settingsData.warnUnsavedNew)
  {
    WarnUnsavedDialog dialog(this);
    int result = dialog.exec();
    _settingsData.warnUnsavedNew = dialog.checked();
    if (result == QDialog::Accepted) return;
  }

  QString openFileName = QFileDialog::getOpenFileName(
      this, tr("Open QMPlot document"), QString(),
      tr("QMPlot documents (*.qmplot);;All files (*.*)"));

  if (openFileName.isEmpty()) return;

  if (!_functionDB->openFile(openFileName))
  {
    QMessageBox::critical(this, tr("Error"),
                          tr("Could not open file '%1'.").arg(openFileName),
                          QMessageBox::Ok);
    return;
  }

  if (_ui->functionsList->count() > 0)
  {
    disconnect(_ui->functionsList, SIGNAL(currentTextChanged(const QString &)),
               this, SLOT(functionSelected(const QString &)));
  }

  _ui->functionsList->clear();

  QList<Function*> list = _functionDB->functionList();
  for (int i = 0; i < list.size(); ++i)
  {
    QListWidgetItem *item = new QListWidgetItem;
    item->setFlags(item->flags() | Qt::ItemIsUserCheckable);
    item->setCheckState(Qt::Checked);
    item->setText(list.at(i)->name());
    item->setForeground(QBrush(list.at(i)->color()));

    _ui->functionsList->addItem(item);
    item = NULL;
  }

  connect(_ui->functionsList, SIGNAL(currentTextChanged(const QString &)),
          this, SLOT(functionSelected(const QString &)));

  _ui->functionsList->setCurrentRow(0);

  _ui->removeButton->setEnabled(true);
  _ui->propertiesDock->setEnabled(true);

  setWindowModified(false);

  _fileName = openFileName;

  QFileInfo info(_fileName);
  setWindowTitle(tr("QMPlot - %1[*]").arg(info.baseName()));

  update();
}

void MainWindow::actionSave()
{
  if (_fileName.isEmpty())
  {
    actionSaveAs();
    return;
  }

  if (!_functionDB->saveFile(_fileName))
  {
    QMessageBox::critical(this, tr("Error"),
                          tr("Could not save file '%1'.").arg(_fileName),
                          QMessageBox::Ok);
    return;
  }
  setWindowModified(false);
}

void MainWindow::actionSaveAs()
{
  QString saveFileName = QFileDialog::getSaveFileName(
      this, tr("Open QMPlot document"), QString(),
      tr("QMPlot documents (*.qmplot);;All files (*.*)"));

  if (saveFileName.isEmpty()) return;

  if (!_functionDB->saveFile(saveFileName))
  {
    QMessageBox::critical(this, tr("Error"),
                          tr("Could not save file '%1'.").arg(saveFileName),
                          QMessageBox::Ok);
    return;
  }

  _fileName = saveFileName;
  setWindowModified(false);
  QFileInfo info(_fileName);
  setWindowTitle(tr("QMPlot - %1[*]").arg(info.baseName()));
}

void MainWindow::actionExport()
{
  ExportData data;
  data.scale = _ui->plot->scale();
  data.xMin = _ui->plot->xMin();
  data.xMax = _ui->plot->xMax();
  data.yMin = _ui->plot->yMin();
  data.yMax = _ui->plot->yMax();
  _exportDialog->setData(data);
  _exportDialog->show();
}

void MainWindow::exportDialogAccepted()
{
  ExportData data = _exportDialog->data();
  _ui->plot->exportPlot(data);

  bool result = data.pixmap->save(data.fileName);

  delete data.pixmap;
  data.pixmap = NULL;

  if (!result)
    QMessageBox::critical(this, tr("QMPlot - Error"),
                          tr("Could not save image to file \'%1\'.").arg(data.fileName),
                          QMessageBox::Ok);
}

void MainWindow::actionPreferences()
{
  _preferencesDialog->setData(_settingsData);
  _preferencesDialog->show();
}

void MainWindow::preferencesDialogAccepted()
{
  settingsChanged(_preferencesDialog->data());
}

void MainWindow::closeEvent(QCloseEvent *e)
{
  if (isWindowModified() && _settingsData.warnUnsavedAtExit)
  {
    WarnUnsavedDialog dialog(this);
    _settingsData.warnUnsavedAtExit = dialog.checked();
    int result = dialog.exec();
    if (result == QDialog::Accepted)
    {
      e->ignore();
      return;
    }
  }

  saveSettings();

  e->accept();
}
